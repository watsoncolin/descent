//
//  TextureGenerator.swift
//  DESCENT
//
//  Procedural pixel art texture generator for minerals
//

import SpriteKit

class TextureGenerator {

    // MARK: - Shared Instance
    static let shared = TextureGenerator()

    // Texture cache to avoid regenerating
    private var textureCache: [String: SKTexture] = [:]

    // MARK: - Public API
    // NOTE: Material textures removed - materials now use PNG assets via MaterialDeposit system

    /// Get or generate a texture for terrain (dirt/stone) at a given depth
    func terrainTexture(depth: Double) -> SKTexture {
        let cacheKey = "terrain_\(Int(depth / 50))" // Cache by 50m intervals

        if let cached = textureCache[cacheKey] {
            return cached
        }

        let texture = generateTerrainTexture(depth: depth)
        textureCache[cacheKey] = texture
        return texture
    }


    /// Get or generate texture for Bedrock obstacle
    func bedrockTexture() -> SKTexture {
        let cacheKey = "bedrock"
        if let cached = textureCache[cacheKey] {
            return cached
        }
        let texture = generateBedrockTexture()
        textureCache[cacheKey] = texture
        return texture
    }

    /// Get or generate texture for Hard Crystal obstacle
    func hardCrystalTexture() -> SKTexture {
        let cacheKey = "hardCrystal"
        if let cached = textureCache[cacheKey] {
            return cached
        }
        let texture = generateHardCrystalTexture()
        textureCache[cacheKey] = texture
        return texture
    }

    /// Get or generate texture for Reinforced Rock obstacle
    func reinforcedRockTexture() -> SKTexture {
        let cacheKey = "reinforcedRock"
        if let cached = textureCache[cacheKey] {
            return cached
        }
        let texture = generateReinforcedRockTexture()
        textureCache[cacheKey] = texture
        return texture
    }

    // MARK: - Terrain Textures

    private func generateTerrainTexture(depth: Double) -> SKTexture {
        let size = CGSize(width: 64, height: 64)  // Full block size for smooth rendering

        // Use scale of 1.0 to prevent renderer from multiplying dimensions by screen scale
        let format = UIGraphicsImageRendererFormat.default()
        format.scale = 1.0
        let renderer = UIGraphicsImageRenderer(size: size, format: format)

        let image = renderer.image { context in
            let ctx = context.cgContext

            // Determine base colors based on depth (smooth gradients, not pixel-art)
            let topColor: UIColor
            let bottomColor: UIColor

            if depth < 100 {
                // Shallow dirt - light brown gradient
                topColor = UIColor(red: 0.60, green: 0.50, blue: 0.40, alpha: 1.0)
                bottomColor = UIColor(red: 0.50, green: 0.40, blue: 0.30, alpha: 1.0)
            } else if depth < 300 {
                // Deep dirt - darker brown gradient
                topColor = UIColor(red: 0.50, green: 0.40, blue: 0.30, alpha: 1.0)
                bottomColor = UIColor(red: 0.40, green: 0.30, blue: 0.20, alpha: 1.0)
            } else {
                // Stone - gray gradient
                topColor = UIColor(red: 0.35, green: 0.35, blue: 0.35, alpha: 1.0)
                bottomColor = UIColor(red: 0.25, green: 0.25, blue: 0.25, alpha: 1.0)
            }

            // Create smooth vertical gradient
            let colorSpace = CGColorSpaceCreateDeviceRGB()
            let colors = [topColor.cgColor, bottomColor.cgColor] as CFArray
            guard let gradient = CGGradient(colorsSpace: colorSpace, colors: colors, locations: [0.0, 1.0]) else {
                return
            }

            let startPoint = CGPoint(x: size.width / 2, y: 0)
            let endPoint = CGPoint(x: size.width / 2, y: size.height)
            ctx.drawLinearGradient(gradient, start: startPoint, end: endPoint, options: [])

            // Add subtle noise texture (fewer, larger dots for smooth look)
            let noiseColor = UIColor(white: 0.0, alpha: 0.15)
            ctx.setFillColor(noiseColor.cgColor)

            // Add 15-25 random noise dots for subtle texture
            let dotCount = Int.random(in: 15...25)
            for _ in 0..<dotCount {
                let x = CGFloat.random(in: 0...size.width)
                let y = CGFloat.random(in: 0...size.height)
                let radius = CGFloat.random(in: 1.5...3.0)
                ctx.fillEllipse(in: CGRect(x: x - radius/2, y: y - radius/2, width: radius, height: radius))
            }
        }

        return SKTexture(image: image)
    }

    // MARK: - Obstacle Block Textures

    private func generateBedrockTexture() -> SKTexture {
        let size = CGSize(width: 64, height: 64)  // Full block size for smooth rendering

        // Use scale of 1.0 to prevent renderer from multiplying dimensions by screen scale
        let format = UIGraphicsImageRendererFormat.default()
        format.scale = 1.0
        let renderer = UIGraphicsImageRenderer(size: size, format: format)

        let image = renderer.image { context in
            let ctx = context.cgContext

            // Very dark purple gradient (#2a1a3a → #1a0a2a)
            let topColor = UIColor(red: 0x2a / 255.0, green: 0x1a / 255.0, blue: 0x3a / 255.0, alpha: 1.0)
            let bottomColor = UIColor(red: 0x1a / 255.0, green: 0x0a / 255.0, blue: 0x2a / 255.0, alpha: 1.0)

            // Create vertical gradient
            let colors = [topColor.cgColor, bottomColor.cgColor] as CFArray
            let colorSpace = CGColorSpaceCreateDeviceRGB()
            guard let gradient = CGGradient(colorsSpace: colorSpace, colors: colors, locations: [0.0, 1.0]) else {
                return
            }

            let startPoint = CGPoint(x: size.width / 2, y: 0)
            let endPoint = CGPoint(x: size.width / 2, y: size.height)
            ctx.drawLinearGradient(gradient, start: startPoint, end: endPoint, options: [])

            // Add subtle noise for texture
            let lighter = UIColor(red: 0x35 / 255.0, green: 0x25 / 255.0, blue: 0x45 / 255.0, alpha: 0.15)
            lighter.setFill()

            for _ in 0..<30 {
                let x = CGFloat.random(in: 0...size.width)
                let y = CGFloat.random(in: 0...size.height)
                let radius = CGFloat.random(in: 1...3)
                ctx.fillEllipse(in: CGRect(x: x, y: y, width: radius, height: radius))
            }
        }

        return SKTexture(image: image)
    }

    private func generateHardCrystalTexture() -> SKTexture {
        let size = 24
        let scale: CGFloat = 3.0

        UIGraphicsBeginImageContextWithOptions(CGSize(width: size, height: size), false, scale)
        guard let context = UIGraphicsGetCurrentContext() else {
            UIGraphicsEndImageContext()
            return SKTexture()
        }

        // Bright purple crystal (#8B00FF)
        let crystal = UIColor(red: 0x8B / 255.0, green: 0x00 / 255.0, blue: 0xFF / 255.0, alpha: 1.0)
        let dark = UIColor(red: 0x60 / 255.0, green: 0x00 / 255.0, blue: 0xB0 / 255.0, alpha: 1.0)
        let bright = UIColor(red: 0xB0 / 255.0, green: 0x40 / 255.0, blue: 0xFF / 255.0, alpha: 1.0)

        // Fill with base color
        crystal.setFill()
        context.fill(CGRect(x: 0, y: 0, width: size, height: size))

        // Draw crystalline facets
        let center = size / 2

        // Dark facets (shadow side)
        dark.setFill()
        context.fill(CGRect(x: 0, y: 0, width: center, height: center))
        context.fill(CGRect(x: center, y: center, width: center, height: center))

        // Bright facets (light side)
        bright.setFill()
        context.fill(CGRect(x: center, y: 0, width: center, height: center))
        context.fill(CGRect(x: 0, y: center, width: center, height: center))

        // Add diagonal crystal lines
        bright.setFill()
        for i in stride(from: -size, to: size * 2, by: 6) {
            context.fill(CGRect(x: i, y: 0, width: 1, height: size))
            // Diagonal line
            let path = CGMutablePath()
            path.move(to: CGPoint(x: i, y: 0))
            path.addLine(to: CGPoint(x: i + size, y: size))
            context.addPath(path)
            context.setLineWidth(1)
            context.strokePath()
        }

        // Sparkle highlights
        bright.setFill()
        context.fill(CGRect(x: center - 1, y: center - 1, width: 2, height: 2))
        context.fill(CGRect(x: size - 4, y: 3, width: 2, height: 2))
        context.fill(CGRect(x: 3, y: size - 4, width: 2, height: 2))

        let image = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()

        return SKTexture(image: image ?? UIImage())
    }

    private func generateReinforcedRockTexture() -> SKTexture {
        let size = 24
        let scale: CGFloat = 3.0

        UIGraphicsBeginImageContextWithOptions(CGSize(width: size, height: size), false, scale)
        guard let context = UIGraphicsGetCurrentContext() else {
            UIGraphicsEndImageContext()
            return SKTexture()
        }

        // Medium purple reinforced rock (#5a3a6a)
        let reinforced = UIColor(red: 0x5a / 255.0, green: 0x3a / 255.0, blue: 0x6a / 255.0, alpha: 1.0)
        let dark = UIColor(red: 0x45 / 255.0, green: 0x25 / 255.0, blue: 0x55 / 255.0, alpha: 1.0)
        let light = UIColor(red: 0x70 / 255.0, green: 0x50 / 255.0, blue: 0x80 / 255.0, alpha: 1.0)
        let metallic = UIColor(red: 0x90 / 255.0, green: 0x70 / 255.0, blue: 0xa0 / 255.0, alpha: 1.0)

        // Fill with base color
        reinforced.setFill()
        context.fill(CGRect(x: 0, y: 0, width: size, height: size))

        // Add stone texture
        for y in 0..<size {
            for x in 0..<size {
                let random = Double.random(in: 0...1)
                if random < 0.2 {
                    dark.setFill()
                    context.fill(CGRect(x: x, y: y, width: 1, height: 1))
                } else if random > 0.85 {
                    light.setFill()
                    context.fill(CGRect(x: x, y: y, width: 1, height: 1))
                }
            }
        }

        // Add metallic reinforcement lines (grid pattern)
        metallic.setFill()
        // Horizontal reinforcement bars
        context.fill(CGRect(x: 0, y: size / 3, width: size, height: 1))
        context.fill(CGRect(x: 0, y: 2 * size / 3, width: size, height: 1))
        // Vertical reinforcement bars
        context.fill(CGRect(x: size / 3, y: 0, width: 1, height: size))
        context.fill(CGRect(x: 2 * size / 3, y: 0, width: 1, height: size))

        // Add rivets at intersections
        dark.setFill()
        context.fill(CGRect(x: size/3 - 1, y: size/3 - 1, width: 2, height: 2))
        context.fill(CGRect(x: 2*size/3 - 1, y: size/3 - 1, width: 2, height: 2))
        context.fill(CGRect(x: size/3 - 1, y: 2*size/3 - 1, width: 2, height: 2))
        context.fill(CGRect(x: 2*size/3 - 1, y: 2*size/3 - 1, width: 2, height: 2))

        let image = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()

        return SKTexture(image: image ?? UIImage())
    }
}

        black.setFill()
        context.fill(CGRect(x: 0, y: 0, width: size, height: size))

        // Add chunky pattern
        drawChunkyPattern(context: context, size: size, color: darkGray, density: 0.3)
    }

    private func drawIronTexture(context: CGContext, size: Int) {
        // Rusty brown iron ore
        let rust = UIColor(red: 0.72, green: 0.45, blue: 0.20, alpha: 1.0)
        let darkRust = UIColor(red: 0.55, green: 0.35, blue: 0.15, alpha: 1.0)
        let lightRust = UIColor(red: 0.85, green: 0.55, blue: 0.30, alpha: 1.0)

        rust.setFill()
        context.fill(CGRect(x: 0, y: 0, width: size, height: size))

        // Streaky pattern
        drawStreakyPattern(context: context, size: size, darkColor: darkRust, lightColor: lightRust)
    }

    private func drawCopperTexture(context: CGContext, size: Int) {
        // Orange-brown copper ore
        let copper = UIColor(red: 0.8, green: 0.5, blue: 0.2, alpha: 1.0)
        let darkCopper = UIColor(red: 0.6, green: 0.35, blue: 0.1, alpha: 1.0)
        let brightCopper = UIColor(red: 0.9, green: 0.6, blue: 0.3, alpha: 1.0)

        copper.setFill()
        context.fill(CGRect(x: 0, y: 0, width: size, height: size))

        // Metallic flecks
        drawMetallicFlecks(context: context, size: size, darkColor: darkCopper, brightColor: brightCopper)
    }

    private func drawSiliconTexture(context: CGContext, size: Int) {
        // Gray silicon with crystalline structure
        let gray = UIColor(red: 0.55, green: 0.55, blue: 0.55, alpha: 1.0)
        let darkGray = UIColor(red: 0.4, green: 0.4, blue: 0.4, alpha: 1.0)
        let lightGray = UIColor(red: 0.7, green: 0.7, blue: 0.7, alpha: 1.0)

        gray.setFill()
        context.fill(CGRect(x: 0, y: 0, width: size, height: size))

        // Crystalline pattern
        drawCrystallinePattern(context: context, size: size, darkColor: darkGray, lightColor: lightGray)
    }

    private func drawAluminumTexture(context: CGContext, size: Int) {
        // Light gray aluminum with metallic sheen
        let aluminum = UIColor(red: 0.66, green: 0.66, blue: 0.66, alpha: 1.0)
        let dark = UIColor(red: 0.5, green: 0.5, blue: 0.5, alpha: 1.0)
        let bright = UIColor(red: 0.8, green: 0.8, blue: 0.8, alpha: 1.0)

        aluminum.setFill()
        context.fill(CGRect(x: 0, y: 0, width: size, height: size))

        // Metallic bands
        drawMetallicBands(context: context, size: size, darkColor: dark, brightColor: bright)
    }

    private func drawSilverTexture(context: CGContext, size: Int) {
        // Shiny silver with highlights
        let silver = UIColor(red: 0.75, green: 0.75, blue: 0.75, alpha: 1.0)
        let dark = UIColor(red: 0.6, green: 0.6, blue: 0.6, alpha: 1.0)
        let bright = UIColor(red: 0.9, green: 0.9, blue: 0.9, alpha: 1.0)

        silver.setFill()
        context.fill(CGRect(x: 0, y: 0, width: size, height: size))

        // Shiny highlights
        drawShinyHighlights(context: context, size: size, darkColor: dark, brightColor: bright)
    }

    private func drawGoldTexture(context: CGContext, size: Int) {
        // Bright golden with glints
        let gold = UIColor(red: 1.0, green: 0.84, blue: 0.0, alpha: 1.0)
        let darkGold = UIColor(red: 0.8, green: 0.65, blue: 0.0, alpha: 1.0)
        let brightGold = UIColor(red: 1.0, green: 0.95, blue: 0.4, alpha: 1.0)

        gold.setFill()
        context.fill(CGRect(x: 0, y: 0, width: size, height: size))

        // Golden glints
        drawGoldenGlints(context: context, size: size, darkColor: darkGold, brightColor: brightGold)
    }

    private func drawPlatinumTexture(context: CGContext, size: Int) {
        // Platinum white with subtle shimmer
        let platinum = UIColor(red: 0.9, green: 0.89, blue: 0.88, alpha: 1.0)
        let dark = UIColor(red: 0.75, green: 0.74, blue: 0.73, alpha: 1.0)
        let bright = UIColor(red: 1.0, green: 1.0, blue: 1.0, alpha: 1.0)

        platinum.setFill()
        context.fill(CGRect(x: 0, y: 0, width: size, height: size))

        drawShinyHighlights(context: context, size: size, darkColor: dark, brightColor: bright)
    }

    private func drawGemTexture(context: CGContext, size: Int, color: UIColor) {
        // Faceted gem with sparkles
        let dark = color.darker(by: 0.3)
        let bright = color.lighter(by: 0.3)

        color.setFill()
        context.fill(CGRect(x: 0, y: 0, width: size, height: size))

        // Draw facets
        drawGemFacets(context: context, size: size, baseColor: color, darkColor: dark, brightColor: bright)
    }

    private func drawTitaniumTexture(context: CGContext, size: Int) {
        // Dark silver titanium
        let titanium = UIColor(red: 0.53, green: 0.53, blue: 0.51, alpha: 1.0)
        let dark = UIColor(red: 0.4, green: 0.4, blue: 0.38, alpha: 1.0)
        let bright = UIColor(red: 0.65, green: 0.65, blue: 0.63, alpha: 1.0)

        titanium.setFill()
        context.fill(CGRect(x: 0, y: 0, width: size, height: size))

        drawMetallicBands(context: context, size: size, darkColor: dark, brightColor: bright)
    }

    private func drawNeodymiumTexture(context: CGContext, size: Int) {
        // Purple-silver magnetic material
        let neodymium = UIColor(red: 0.6, green: 0.4, blue: 0.8, alpha: 1.0)
        let dark = UIColor(red: 0.45, green: 0.3, blue: 0.6, alpha: 1.0)
        let bright = UIColor(red: 0.75, green: 0.55, blue: 0.95, alpha: 1.0)

        neodymium.setFill()
        context.fill(CGRect(x: 0, y: 0, width: size, height: size))

        drawMagneticPattern(context: context, size: size, darkColor: dark, brightColor: bright)
    }

    private func drawRhodiumTexture(context: CGContext, size: Int) {
        // Ultra-reflective silver
        let rhodium = UIColor(red: 1.0, green: 0.98, blue: 0.98, alpha: 1.0)
        let dark = UIColor(red: 0.8, green: 0.78, blue: 0.78, alpha: 1.0)
        let bright = UIColor(red: 1.0, green: 1.0, blue: 1.0, alpha: 1.0)

        rhodium.setFill()
        context.fill(CGRect(x: 0, y: 0, width: size, height: size))

        drawMirrorSheen(context: context, size: size, darkColor: dark, brightColor: bright)
    }

    private func drawDarkMatterTexture(context: CGContext, size: Int) {
        // Dark purple with mysterious glow
        let darkMatter = UIColor(red: 0.1, green: 0.1, blue: 0.18, alpha: 1.0)
        let purple = UIColor(red: 0.3, green: 0.2, blue: 0.5, alpha: 1.0)
        let glow = UIColor(red: 0.5, green: 0.3, blue: 0.8, alpha: 1.0)

        darkMatter.setFill()
        context.fill(CGRect(x: 0, y: 0, width: size, height: size))

        drawVoidPattern(context: context, size: size, purple: purple, glow: glow)
    }

    // MARK: - Pattern Helpers

    private func drawChunkyPattern(context: CGContext, size: Int, color: UIColor, density: Double) {
        color.setFill()
        for y in 0..<size {
            for x in 0..<size {
                if Double.random(in: 0...1) < density {
                    context.fill(CGRect(x: x, y: y, width: 1, height: 1))
                }
            }
        }
    }

    private func drawStreakyPattern(context: CGContext, size: Int, darkColor: UIColor, lightColor: UIColor) {
        for y in stride(from: 0, to: size, by: 3) {
            if Bool.random() {
                darkColor.setFill()
            } else {
                lightColor.setFill()
            }
            context.fill(CGRect(x: 0, y: y, width: size, height: 2))
        }
    }

    private func drawMetallicFlecks(context: CGContext, size: Int, darkColor: UIColor, brightColor: UIColor) {
        for _ in 0..<8 {
            let x = Int.random(in: 0..<size)
            let y = Int.random(in: 0..<size)
            brightColor.setFill()
            context.fill(CGRect(x: x, y: y, width: 2, height: 2))
        }
        for _ in 0..<6 {
            let x = Int.random(in: 0..<size)
            let y = Int.random(in: 0..<size)
            darkColor.setFill()
            context.fill(CGRect(x: x, y: y, width: 2, height: 2))
        }
    }

    private func drawCrystallinePattern(context: CGContext, size: Int, darkColor: UIColor, lightColor: UIColor) {
        // Diagonal stripes for crystal structure
        for i in stride(from: -size, to: size * 2, by: 4) {
            lightColor.setFill()
            let path = CGMutablePath()
            path.move(to: CGPoint(x: i, y: 0))
            path.addLine(to: CGPoint(x: i + 2, y: 0))
            path.addLine(to: CGPoint(x: i + 2 + size, y: size))
            path.addLine(to: CGPoint(x: i + size, y: size))
            path.closeSubpath()
            context.addPath(path)
            context.fillPath()
        }
    }

    private func drawMetallicBands(context: CGContext, size: Int, darkColor: UIColor, brightColor: UIColor) {
        for x in stride(from: 0, to: size, by: 4) {
            brightColor.setFill()
            context.fill(CGRect(x: x, y: 0, width: 1, height: size))
            darkColor.setFill()
            context.fill(CGRect(x: x + 2, y: 0, width: 1, height: size))
        }
    }

    private func drawShinyHighlights(context: CGContext, size: Int, darkColor: UIColor, brightColor: UIColor) {
        // Diagonal highlights
        brightColor.setFill()
        context.fill(CGRect(x: size/2, y: size/4, width: size/3, height: size/8))
        context.fill(CGRect(x: size/4, y: size*2/3, width: size/4, height: size/10))

        darkColor.setFill()
        context.fill(CGRect(x: 0, y: 0, width: size/3, height: size/4))
    }

    private func drawGoldenGlints(context: CGContext, size: Int, darkColor: UIColor, brightColor: UIColor) {
        // Random bright spots
        for _ in 0..<12 {
            let x = Int.random(in: 0..<size)
            let y = Int.random(in: 0..<size)
            brightColor.setFill()
            context.fill(CGRect(x: x, y: y, width: 1, height: 1))
        }
        // Dark veins
        darkColor.setFill()
        for i in stride(from: 0, to: size, by: 6) {
            context.fill(CGRect(x: i, y: 0, width: 1, height: size))
        }
    }

    private func drawGemFacets(context: CGContext, size: Int, baseColor: UIColor, darkColor: UIColor, brightColor: UIColor) {
        // Draw faceted gem appearance
        let center = size / 2

        // Dark facets
        darkColor.setFill()
        context.fill(CGRect(x: 0, y: 0, width: center, height: center))
        context.fill(CGRect(x: center, y: center, width: center, height: center))

        // Bright facets
        brightColor.setFill()
        context.fill(CGRect(x: center, y: 0, width: center, height: center))
        context.fill(CGRect(x: 0, y: center, width: center, height: center))

        // Sparkle points
        brightColor.setFill()
        context.fill(CGRect(x: center - 1, y: center - 1, width: 2, height: 2))
        context.fill(CGRect(x: size - 3, y: 2, width: 2, height: 2))
        context.fill(CGRect(x: 2, y: size - 3, width: 2, height: 2))
    }

    private func drawMagneticPattern(context: CGContext, size: Int, darkColor: UIColor, brightColor: UIColor) {
        // Wavy magnetic field lines
        for y in stride(from: 0, to: size, by: 4) {
            for x in 0..<size {
                if (x + y/2) % 4 == 0 {
                    brightColor.setFill()
                    context.fill(CGRect(x: x, y: y, width: 1, height: 1))
                }
            }
        }
    }

    private func drawMirrorSheen(context: CGContext, size: Int, darkColor: UIColor, brightColor: UIColor) {
        // Ultra-reflective diagonal gradient
        for y in 0..<size {
            for x in 0..<size {
                if (x + y) < size {
                    brightColor.setFill()
                } else {
                    darkColor.setFill()
                }
                context.fill(CGRect(x: x, y: y, width: 1, height: 1))
            }
        }
    }

    private func drawVoidPattern(context: CGContext, size: Int, purple: UIColor, glow: UIColor) {
        // Swirling void effect
        for y in 0..<size {
            for x in 0..<size {
                let distance = sqrt(pow(Double(x - size/2), 2) + pow(Double(y - size/2), 2))
                if distance < Double(size/3) && Int(distance) % 3 == 0 {
                    glow.setFill()
                    context.fill(CGRect(x: x, y: y, width: 1, height: 1))
                } else if Int.random(in: 0...20) == 0 {
                    purple.setFill()
                    context.fill(CGRect(x: x, y: y, width: 1, height: 1))
                }
            }
        }
    }
    */

    // MARK: - Material Rendering
    // NOTE: Materials are now rendered using PNG assets via MaterialDeposit system
    // Two sections of pixel-art material generation code have been commented out:
    //   1. generateTexture(for: MaterialType) method (~55 lines)
    //   2. All draw*Texture helper methods (~300 lines)
}

// MARK: - UIColor Extensions

extension UIColor {
    func darker(by percentage: CGFloat = 0.3) -> UIColor {
        return self.adjust(by: -abs(percentage))
    }

    func lighter(by percentage: CGFloat = 0.3) -> UIColor {
        return self.adjust(by: abs(percentage))
    }

    func adjust(by percentage: CGFloat) -> UIColor {
        var red: CGFloat = 0, green: CGFloat = 0, blue: CGFloat = 0, alpha: CGFloat = 0
        self.getRed(&red, green: &green, blue: &blue, alpha: &alpha)
        return UIColor(
            red: min(red + percentage, 1.0),
            green: min(green + percentage, 1.0),
            blue: min(blue + percentage, 1.0),
            alpha: alpha
        )
    }
}

// MARK: - Continuous Terrain Texture Generation

extension TextureGenerator {

    /// Create vertical gradient texture for continuous terrain layers
    func createVerticalGradientTexture(size: CGSize, colors: [UIColor]) -> SKTexture {
        // Metal texture size limit: 8192 pixels max (conservative limit for safety)
        let maxDimension: CGFloat = 4096.0

        if size.width > maxDimension || size.height > maxDimension {
            print("⚠️ ERROR: Attempted to create texture larger than Metal limit!")
            print("   Requested: \(size.width)x\(size.height)")
            print("   Maximum: \(maxDimension)x\(maxDimension)")

            // Clamp to maximum size
            let clampedSize = CGSize(
                width: min(size.width, maxDimension),
                height: min(size.height, maxDimension)
            )
            print("   Clamping to: \(clampedSize.width)x\(clampedSize.height)")

            return createVerticalGradientTexture(size: clampedSize, colors: colors)
        }

        // Use scale of 1.0 to prevent renderer from multiplying dimensions by screen scale
        let format = UIGraphicsImageRendererFormat.default()
        format.scale = 1.0
        let renderer = UIGraphicsImageRenderer(size: size, format: format)

        let image = renderer.image { context in
            // Create evenly spaced locations for gradient stops
            let locations: [CGFloat] = (0..<colors.count).map { CGFloat($0) / CGFloat(colors.count - 1) }

            guard let gradient = CGGradient(
                colorsSpace: CGColorSpaceCreateDeviceRGB(),
                colors: colors.map { $0.cgColor } as CFArray,
                locations: locations
            ) else { return }

            context.cgContext.drawLinearGradient(
                gradient,
                start: .zero,
                end: CGPoint(x: 0, y: size.height),
                options: []
            )
        }
        return SKTexture(image: image)
    }

    /// Create radial gradient texture (for material deposits and glows)
    func createRadialGradientTexture(radius: CGFloat, colors: [UIColor]) -> SKTexture {
        // Metal texture size limit: 8192 pixels max (conservative limit for safety)
        let maxDimension: CGFloat = 4096.0
        let size = CGSize(width: radius * 2, height: radius * 2)

        if size.width > maxDimension || size.height > maxDimension {
            print("⚠️ ERROR: Attempted to create radial texture larger than Metal limit!")
            print("   Requested radius: \(radius) (size: \(size.width)x\(size.height))")
            print("   Maximum: \(maxDimension)x\(maxDimension)")

            // Clamp to maximum size
            let clampedRadius = maxDimension / 2
            print("   Clamping radius to: \(clampedRadius)")

            return createRadialGradientTexture(radius: clampedRadius, colors: colors)
        }

        // Use scale of 1.0 to prevent renderer from multiplying dimensions by screen scale
        let format = UIGraphicsImageRendererFormat.default()
        format.scale = 1.0
        let renderer = UIGraphicsImageRenderer(size: size, format: format)

        let image = renderer.image { context in
            // Create evenly spaced locations for gradient stops
            let locations: [CGFloat] = (0..<colors.count).map { CGFloat($0) / CGFloat(colors.count - 1) }

            guard let gradient = CGGradient(
                colorsSpace: CGColorSpaceCreateDeviceRGB(),
                colors: colors.map { $0.cgColor } as CFArray,
                locations: locations
            ) else { return }

            context.cgContext.drawRadialGradient(
                gradient,
                startCenter: CGPoint(x: radius, y: radius),
                startRadius: 0,
                endCenter: CGPoint(x: radius, y: radius),
                endRadius: radius,
                options: []
            )
        }
        return SKTexture(image: image)
    }

    /// Create diagonal gradient texture for flow patterns
    func createDiagonalGradientTexture(size: CGSize, colors: [UIColor], angle: CGFloat) -> SKTexture {
        // Metal texture size limit: 8192 pixels max (conservative limit for safety)
        let maxDimension: CGFloat = 4096.0

        if size.width > maxDimension || size.height > maxDimension {
            print("⚠️ ERROR: Attempted to create diagonal texture larger than Metal limit!")
            print("   Requested: \(size.width)x\(size.height)")
            print("   Maximum: \(maxDimension)x\(maxDimension)")

            // Clamp to maximum size
            let clampedSize = CGSize(
                width: min(size.width, maxDimension),
                height: min(size.height, maxDimension)
            )
            print("   Clamping to: \(clampedSize.width)x\(clampedSize.height)")

            return createDiagonalGradientTexture(size: clampedSize, colors: colors, angle: angle)
        }

        // Use scale of 1.0 to prevent renderer from multiplying dimensions by screen scale
        let format = UIGraphicsImageRendererFormat.default()
        format.scale = 1.0
        let renderer = UIGraphicsImageRenderer(size: size, format: format)

        let image = renderer.image { context in
            // Create evenly spaced locations for gradient stops
            let locations: [CGFloat] = (0..<colors.count).map { CGFloat($0) / CGFloat(colors.count - 1) }

            guard let gradient = CGGradient(
                colorsSpace: CGColorSpaceCreateDeviceRGB(),
                colors: colors.map { $0.cgColor } as CFArray,
                locations: locations
            ) else { return }

            // Convert angle to radians
            let angleRad = angle * .pi / 180.0

            // Calculate gradient endpoints based on angle
            let endX = cos(angleRad) * size.width
            let endY = sin(angleRad) * size.height

            context.cgContext.drawLinearGradient(
                gradient,
                start: .zero,
                end: CGPoint(x: endX, y: endY),
                options: []
            )
        }
        return SKTexture(image: image)
    }
}
